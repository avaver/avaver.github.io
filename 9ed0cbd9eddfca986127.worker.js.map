{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/cubejs/index.js","webpack:///./node_modules/cubejs/lib/solve.js","webpack:///./node_modules/cubejs/lib/cube.js","webpack:///./src/classes/cubejs.worker.ts","webpack:///(webpack)/buildin/module.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","B","BL","BR","Cnk","Cube","D","DB","DBL","DF","DFR","DL","DLF","DR","DRB","F","FL","FR","Include","L","N_FLIP","N_FRtoBR","N_PARITY","N_SLICE1","N_SLICE2","N_TWIST","N_UBtoDF","N_URFtoDLF","N_URtoDF","N_URtoUL","R","U","UB","UBR","UF","UFL","UL","ULB","UR","URF","allMoves1","allMoves2","computeMoveTable","computePruningTable","faceNames","faceNums","factorial","max","mergeURtoDF","moveTableParams","nextMoves1","nextMoves2","permutationIndex","pruning","pruningTableParams","rotateLeft","rotateRight","indexOf","this","k","j","f","ref","a","b","array","ref1","tmp","context","start","end","fromEnd","maxAll","maxB","maxOur","our","permName","results","push","index","perm","q","ref10","ref2","ref3","ref4","ref5","ref6","ref7","ref8","ref9","u","w","x","y","z","twist","ori","parity","v","co","flip","eo","cornerParity","cp","edgeParity","ep","URFtoDLF","URtoUL","UBtoDF","URtoDF","FRtoBR","coord","size","apply","cube","inner","move","moves","moveTables","computeMoveTables","tables","len","scope","tableName","length","results1","face","lastFace","next","power","powers","table","pos","shift","slot","phase","currentCoords","nextIndex","current","depth","done","Math","ceil","pruningTables","sliceTwist","sliceFlip","sliceURFtoDLFParity","sliceURtoDFParity","newSlice","newTwist","slice","newFlip","newParity","newURFtoDLF","newURtoDF","computePruningTables","params","initSolver","solveUpright","maxDepth","State","freeStates","moveNames","phase1","phase1search","phase2","phase2search","solution","state","faceName","powerName","result","[object Object]","parent","lastMove","init","d1","d2","pop","index1","index2","top","init2","minDist1","moves1","next1","minDist2","moves2","next2","substring","0","1","2","3","4","5","solve","clone","rotation","upright","uprightSolution","center","split","join","scramble","inverse","random","centerColor","centerFacelet","cornerColor","cornerFacelet","edgeColor","edgeFacelet","_B","_D","_F","_L","_R","_U","parseAlg","other","identity","newCenter","newCp","newEp","newCo","newEo","corner","edge","str","col1","col2","toJSON","randomize","cent","e","from","to","centerMultiply","cornerMultiply","edgeMultiply","arg","multiply","reverse","arePermutationsValid","generateValidRandomOrientation","generateValidRandomPermutation","getNumSwaps","isOrientationValid","randint","randomizeOrientation","shuffle","min","floor","currentIndex","randomIndex","arr","cur","cycleLength","numSwaps","seen","numOrientations","reduce","E","M","S","6","7","8","9","10","11","12","13","14","15","16","17","part","Error","cubejs","ctx","self","initialized","onmessage","event","data","cmd","postMessage","webpackPolyfill","deprecate","paths","children"],"mappings":"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AAnJ,EAAA,GACAqJ,EAAArJ,EAAA,IAGAsE,EAAA,WAGA,OAFA2E,EAAA7L,KAAA8C,GAAA9C,KAAAgD,IACA4I,EAAA5L,KAAA0C,GAAA1C,KAAA4C,IACA5C,MAEAkH,EAnGA,GAsGAvK,EAAAiH,MAAA,CACA,CAEAoF,OAAA,cACAlG,GAAA,CAAAvE,EACAM,EACAJ,EACAE,EACA3B,EACAE,EACAJ,EACAM,GACAsF,GAAA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,GACAM,GAAA,CAAA1E,EACAM,EACAJ,EACAE,EACAvB,EACAJ,EACAE,EACAJ,EACAU,EACAD,EACAd,EACAC,GACAmG,GAAA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAEA,CAEAoG,OAAA,cACAlG,GAAA,CAAA9F,EACAyB,EACAE,EACAE,EACAzB,EACAF,EACAJ,EACAyB,GACAmE,GAAA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,GACAM,GAAA,CAAAzF,EACAiB,EACAE,EACAJ,EACA7B,EACAM,EACAE,EACAJ,EACAM,EACAG,EACAd,EACAoC,GACAgE,GAAA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAEA,CAEAoG,OAAA,cACAlG,GAAA,CAAArE,EACAvB,EACAyB,EACAJ,EACAM,EACA7B,EACAF,EACAM,GACAsF,GAAA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,GACAM,GAAA,CAAApE,EACAtB,EACAoB,EACAJ,EACAnB,EACAI,EACAN,EACAJ,EACA2B,EACAzB,EACAP,EACAC,GACAmG,GAAA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAEA,CAEAoG,OAAA,cACAlG,GAAA,CAAAjE,EACAJ,EACAE,EACAJ,EACArB,EACAJ,EACAM,EACAJ,GACA0F,GAAA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,GACAM,GAAA,CAAApE,EACAJ,EACAE,EACAJ,EACAvB,EACAE,EACAJ,EACAM,EACAI,EACAD,EACAd,EACAC,GACAmG,GAAA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAEA,CAEAoG,OAAA,cACAlG,GAAA,CAAAjE,EACAF,EACA7B,EACAyB,EACAvB,EACAyB,EACAvB,EACAE,GACAsF,GAAA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,GACAM,GAAA,CAAApE,EACAJ,EACAhC,EACA8B,EACAnB,EACAJ,EACAO,EACAT,EACAU,EACAmB,EACAzB,EACAR,GACAmG,GAAA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAEA,CAEAoG,OAAA,cACAlG,GAAA,CAAAjE,EACAJ,EACAF,EACAnB,EACAJ,EACAE,EACAyB,EACA7B,GACA4F,GAAA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,GACAM,GAAA,CAAApE,EACAJ,EACAE,EACAjC,EACAU,EACAJ,EACAE,EACAT,EACAe,EACAD,EACAgB,EACAzB,GACA+F,GAAA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAEA,CAEAoG,OAAA,CAAA3K,EACAhB,EACAI,EACAb,EACAL,EACA6B,GACA0E,GAAA,CAAAjE,EACAJ,EACAE,EACAJ,EACAvB,EACAE,EACAJ,EACAM,GACAsF,GAAA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,GACAM,GAAA,CAAApE,EACAJ,EACAE,EACAJ,EACAnB,EACAJ,EACAE,EACAJ,EACAS,EACAd,EACAC,EACAc,GACAqF,GAAA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAEA,CAEAoG,OAAA,CAAAzM,EACA6B,EACAC,EACAhB,EACAI,EACAb,GACAkG,GAAA,CAAAjE,EACAJ,EACAE,EACAJ,EACAvB,EACAE,EACAJ,EACAM,GACAsF,GAAA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,GACAM,GAAA,CAAApE,EACAN,EACAI,EACA7B,EACAM,EACAqB,EACAvB,EACAF,EACAQ,EAC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","file":"9ed0cbd9eddfca986127.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"4f78\");\n","module.exports = require('./lib/cube');\nrequire('./lib/solve');\n","(function() {\n  var B, BL, BR, Cnk, Cube, D, DB, DBL, DF, DFR, DL, DLF, DR, DRB, F, FL, FR, Include, L, N_FLIP, N_FRtoBR, N_PARITY, N_SLICE1, N_SLICE2, N_TWIST, N_UBtoDF, N_URFtoDLF, N_URtoDF, N_URtoUL, R, U, UB, UBR, UF, UFL, UL, ULB, UR, URF, allMoves1, allMoves2, computeMoveTable, computePruningTable, faceNames, faceNums, factorial, key, max, mergeURtoDF, moveTableParams, nextMoves1, nextMoves2, permutationIndex, pruning, pruningTableParams, rotateLeft, rotateRight, value,\n    indexOf = [].indexOf;\n\n  Cube = this.Cube || require('./cube');\n\n  // Centers\n  [U, R, F, D, L, B] = [0, 1, 2, 3, 4, 5];\n\n  // Corners\n  [URF, UFL, ULB, UBR, DFR, DLF, DBL, DRB] = [0, 1, 2, 3, 4, 5, 6, 7];\n\n  // Edges\n  [UR, UF, UL, UB, DR, DF, DL, DB, FR, FL, BL, BR] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n\n  //# Helpers\n\n  // n choose k, i.e. the binomial coeffiecient\n  Cnk = function(n, k) {\n    var i, j, s;\n    if (n < k) {\n      return 0;\n    }\n    if (k > n / 2) {\n      k = n - k;\n    }\n    s = 1;\n    i = n;\n    j = 1;\n    while (i !== n - k) {\n      s *= i;\n      s /= j;\n      i--;\n      j++;\n    }\n    return s;\n  };\n\n  // n!\n  factorial = function(n) {\n    var f, i, m, ref;\n    f = 1;\n    for (i = m = 2, ref = n; (2 <= ref ? m <= ref : m >= ref); i = 2 <= ref ? ++m : --m) {\n      f *= i;\n    }\n    return f;\n  };\n\n  // Maximum of two values\n  max = function(a, b) {\n    if (a > b) {\n      return a;\n    } else {\n      return b;\n    }\n  };\n\n  // Rotate elements between l and r left by one place\n  rotateLeft = function(array, l, r) {\n    var i, m, ref, ref1, tmp;\n    tmp = array[l];\n    for (i = m = ref = l, ref1 = r - 1; (ref <= ref1 ? m <= ref1 : m >= ref1); i = ref <= ref1 ? ++m : --m) {\n      array[i] = array[i + 1];\n    }\n    return array[r] = tmp;\n  };\n\n  // Rotate elements between l and r right by one place\n  rotateRight = function(array, l, r) {\n    var i, m, ref, ref1, tmp;\n    tmp = array[r];\n    for (i = m = ref = r, ref1 = l + 1; (ref <= ref1 ? m <= ref1 : m >= ref1); i = ref <= ref1 ? ++m : --m) {\n      array[i] = array[i - 1];\n    }\n    return array[l] = tmp;\n  };\n\n  // Generate a function that computes permutation indices.\n\n  // The permutation index actually encodes two indices: Combination,\n  // i.e. positions of the cubies start..end (A) and their respective\n  // permutation (B). The maximum value for B is\n\n  //   maxB = (end - start + 1)!\n\n  // and the index is A * maxB + B\n  permutationIndex = function(context, start, end, fromEnd = false) {\n    var i, maxAll, maxB, maxOur, our, permName;\n    maxOur = end - start;\n    maxB = factorial(maxOur + 1);\n    if (context === 'corners') {\n      maxAll = 7;\n      permName = 'cp';\n    } else {\n      maxAll = 11;\n      permName = 'ep';\n    }\n    our = (function() {\n      var m, ref, results;\n      results = [];\n      for (i = m = 0, ref = maxOur; (0 <= ref ? m <= ref : m >= ref); i = 0 <= ref ? ++m : --m) {\n        results.push(0);\n      }\n      return results;\n    })();\n    return function(index) {\n      var a, b, c, j, k, m, o, p, perm, q, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, t, u, w, x, y, z;\n      if (index != null) {\n        for (i = m = 0, ref = maxOur; (0 <= ref ? m <= ref : m >= ref); i = 0 <= ref ? ++m : --m) {\n          // Reset our to [start..end]\n          our[i] = i + start;\n        }\n        b = index % maxB; // permutation\n        a = index / maxB | 0; // combination\n        \n        // Invalidate all edges\n        perm = this[permName];\n        for (i = o = 0, ref1 = maxAll; (0 <= ref1 ? o <= ref1 : o >= ref1); i = 0 <= ref1 ? ++o : --o) {\n          perm[i] = -1;\n        }\n// Generate permutation from index b\n        for (j = p = 1, ref2 = maxOur; (1 <= ref2 ? p <= ref2 : p >= ref2); j = 1 <= ref2 ? ++p : --p) {\n          k = b % (j + 1);\n          b = b / (j + 1) | 0;\n          // TODO: Implement rotateRightBy(our, 0, j, k)\n          while (k > 0) {\n            rotateRight(our, 0, j);\n            k--;\n          }\n        }\n        // Generate combination and set our edges\n        x = maxOur;\n        if (fromEnd) {\n          for (j = q = 0, ref3 = maxAll; (0 <= ref3 ? q <= ref3 : q >= ref3); j = 0 <= ref3 ? ++q : --q) {\n            c = Cnk(maxAll - j, x + 1);\n            if (a - c >= 0) {\n              perm[j] = our[maxOur - x];\n              a -= c;\n              x--;\n            }\n          }\n        } else {\n          for (j = t = ref4 = maxAll; (ref4 <= 0 ? t <= 0 : t >= 0); j = ref4 <= 0 ? ++t : --t) {\n            c = Cnk(j, x + 1);\n            if (a - c >= 0) {\n              perm[j] = our[x];\n              a -= c;\n              x--;\n            }\n          }\n        }\n        return this;\n      } else {\n        perm = this[permName];\n        for (i = u = 0, ref5 = maxOur; (0 <= ref5 ? u <= ref5 : u >= ref5); i = 0 <= ref5 ? ++u : --u) {\n          our[i] = -1;\n        }\n        a = b = x = 0;\n        // Compute the index a < ((maxAll + 1) choose (maxOur + 1)) and\n        // the permutation\n        if (fromEnd) {\n          for (j = w = ref6 = maxAll; (ref6 <= 0 ? w <= 0 : w >= 0); j = ref6 <= 0 ? ++w : --w) {\n            if ((start <= (ref7 = perm[j]) && ref7 <= end)) {\n              a += Cnk(maxAll - j, x + 1);\n              our[maxOur - x] = perm[j];\n              x++;\n            }\n          }\n        } else {\n          for (j = y = 0, ref8 = maxAll; (0 <= ref8 ? y <= ref8 : y >= ref8); j = 0 <= ref8 ? ++y : --y) {\n            if ((start <= (ref9 = perm[j]) && ref9 <= end)) {\n              a += Cnk(j, x + 1);\n              our[x] = perm[j];\n              x++;\n            }\n          }\n        }\n// Compute the index b < (maxOur + 1)! for the permutation\n        for (j = z = ref10 = maxOur; (ref10 <= 0 ? z <= 0 : z >= 0); j = ref10 <= 0 ? ++z : --z) {\n          k = 0;\n          while (our[j] !== start + j) {\n            rotateLeft(our, 0, j);\n            k++;\n          }\n          b = (j + 1) * b + k;\n        }\n        return a * maxB + b;\n      }\n    };\n  };\n\n  Include = {\n    // The twist of the 8 corners, 0 <= twist < 3^7. The orientation of\n    // the DRB corner is fully determined by the orientation of the other\n    // corners.\n    twist: function(twist) {\n      var i, m, o, ori, parity, v;\n      if (twist != null) {\n        parity = 0;\n        for (i = m = 6; m >= 0; i = --m) {\n          ori = twist % 3;\n          twist = (twist / 3) | 0;\n          this.co[i] = ori;\n          parity += ori;\n        }\n        this.co[7] = (3 - parity % 3) % 3;\n        return this;\n      } else {\n        v = 0;\n        for (i = o = 0; o <= 6; i = ++o) {\n          v = 3 * v + this.co[i];\n        }\n        return v;\n      }\n    },\n    // The flip of the 12 edges, 0 <= flip < 2^11. The orientation of the\n    // BR edge is fully determined by the orientation of the other edges.\n    flip: function(flip) {\n      var i, m, o, ori, parity, v;\n      if (flip != null) {\n        parity = 0;\n        for (i = m = 10; m >= 0; i = --m) {\n          ori = flip % 2;\n          flip = flip / 2 | 0;\n          this.eo[i] = ori;\n          parity += ori;\n        }\n        this.eo[11] = (2 - parity % 2) % 2;\n        return this;\n      } else {\n        v = 0;\n        for (i = o = 0; o <= 10; i = ++o) {\n          v = 2 * v + this.eo[i];\n        }\n        return v;\n      }\n    },\n    // Parity of the corner permutation\n    cornerParity: function() {\n      var i, j, m, o, ref, ref1, ref2, ref3, s;\n      s = 0;\n      for (i = m = ref = DRB, ref1 = URF + 1; (ref <= ref1 ? m <= ref1 : m >= ref1); i = ref <= ref1 ? ++m : --m) {\n        for (j = o = ref2 = i - 1, ref3 = URF; (ref2 <= ref3 ? o <= ref3 : o >= ref3); j = ref2 <= ref3 ? ++o : --o) {\n          if (this.cp[j] > this.cp[i]) {\n            s++;\n          }\n        }\n      }\n      return s % 2;\n    },\n    // Parity of the edges permutation. Parity of corners and edges are\n    // the same if the cube is solvable.\n    edgeParity: function() {\n      var i, j, m, o, ref, ref1, ref2, ref3, s;\n      s = 0;\n      for (i = m = ref = BR, ref1 = UR + 1; (ref <= ref1 ? m <= ref1 : m >= ref1); i = ref <= ref1 ? ++m : --m) {\n        for (j = o = ref2 = i - 1, ref3 = UR; (ref2 <= ref3 ? o <= ref3 : o >= ref3); j = ref2 <= ref3 ? ++o : --o) {\n          if (this.ep[j] > this.ep[i]) {\n            s++;\n          }\n        }\n      }\n      return s % 2;\n    },\n    // Permutation of the six corners URF, UFL, ULB, UBR, DFR, DLF\n    URFtoDLF: permutationIndex('corners', URF, DLF),\n    // Permutation of the three edges UR, UF, UL\n    URtoUL: permutationIndex('edges', UR, UL),\n    // Permutation of the three edges UB, DR, DF\n    UBtoDF: permutationIndex('edges', UB, DF),\n    // Permutation of the six edges UR, UF, UL, UB, DR, DF\n    URtoDF: permutationIndex('edges', UR, DF),\n    // Permutation of the equator slice edges FR, FL, BL and BR\n    FRtoBR: permutationIndex('edges', FR, BR, true)\n  };\n\n  for (key in Include) {\n    value = Include[key];\n    Cube.prototype[key] = value;\n  }\n\n  computeMoveTable = function(context, coord, size) {\n    var apply, cube, i, inner, j, k, m, move, o, p, ref, results;\n    // Loop through all valid values for the coordinate, setting cube's\n    // state in each iteration. Then apply each of the 18 moves to the\n    // cube, and compute the resulting coordinate.\n    apply = context === 'corners' ? 'cornerMultiply' : 'edgeMultiply';\n    cube = new Cube;\n    results = [];\n    for (i = m = 0, ref = size - 1; (0 <= ref ? m <= ref : m >= ref); i = 0 <= ref ? ++m : --m) {\n      cube[coord](i);\n      inner = [];\n      for (j = o = 0; o <= 5; j = ++o) {\n        move = Cube.moves[j];\n        for (k = p = 0; p <= 2; k = ++p) {\n          cube[apply](move);\n          inner.push(cube[coord]());\n        }\n        // 4th face turn restores the cube\n        cube[apply](move);\n      }\n      results.push(inner);\n    }\n    return results;\n  };\n\n  // Because we only have the phase 2 URtoDF coordinates, we need to\n  // merge the URtoUL and UBtoDF coordinates to URtoDF in the beginning\n  // of phase 2.\n  mergeURtoDF = (function() {\n    var a, b;\n    a = new Cube;\n    b = new Cube;\n    return function(URtoUL, UBtoDF) {\n      var i, m;\n      // Collisions can be found because unset are set to -1\n      a.URtoUL(URtoUL);\n      b.UBtoDF(UBtoDF);\n      for (i = m = 0; m <= 7; i = ++m) {\n        if (a.ep[i] !== -1) {\n          if (b.ep[i] !== -1) {\n            return -1; // collision\n          } else {\n            b.ep[i] = a.ep[i];\n          }\n        }\n      }\n      return b.URtoDF();\n    };\n  })();\n\n  N_TWIST = 2187; // 3^7 corner orientations\n\n  N_FLIP = 2048; // 2^11 possible edge flips\n\n  N_PARITY = 2; // 2 possible parities\n\n  N_FRtoBR = 11880; // 12!/(12-4)! permutations of FR..BR edges\n\n  N_SLICE1 = 495; // (12 choose 4) possible positions of FR..BR edges\n\n  N_SLICE2 = 24; // 4! permutations of FR..BR edges in phase 2\n\n  N_URFtoDLF = 20160; // 8!/(8-6)! permutations of URF..DLF corners\n\n  \n  // The URtoDF move table is only computed for phase 2 because the full\n  // table would have >650000 entries\n  N_URtoDF = 20160; // 8!/(8-6)! permutation of UR..DF edges in phase 2\n\n  N_URtoUL = 1320; // 12!/(12-3)! permutations of UR..UL edges\n\n  N_UBtoDF = 1320; // 12!/(12-3)! permutations of UB..DF edges\n\n  \n  // The move table for parity is so small that it's included here\n  Cube.moveTables = {\n    parity: [[1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]],\n    twist: null,\n    flip: null,\n    FRtoBR: null,\n    URFtoDLF: null,\n    URtoDF: null,\n    URtoUL: null,\n    UBtoDF: null,\n    mergeURtoDF: null\n  };\n\n  // Other move tables are computed on the fly\n  moveTableParams = {\n    // name: [scope, size]\n    twist: ['corners', N_TWIST],\n    flip: ['edges', N_FLIP],\n    FRtoBR: ['edges', N_FRtoBR],\n    URFtoDLF: ['corners', N_URFtoDLF],\n    URtoDF: ['edges', N_URtoDF],\n    URtoUL: ['edges', N_URtoUL],\n    UBtoDF: ['edges', N_UBtoDF],\n    mergeURtoDF: []\n  };\n\n  Cube.computeMoveTables = function(...tables) {\n    var len, m, name, scope, size, tableName;\n    if (tables.length === 0) {\n      tables = (function() {\n        var results;\n        results = [];\n        for (name in moveTableParams) {\n          results.push(name);\n        }\n        return results;\n      })();\n    }\n    for (m = 0, len = tables.length; m < len; m++) {\n      tableName = tables[m];\n      if (this.moveTables[tableName] !== null) {\n        // Already computed\n        continue;\n      }\n      if (tableName === 'mergeURtoDF') {\n        this.moveTables.mergeURtoDF = (function() {\n          var UBtoDF, URtoUL, o, results;\n          results = [];\n          for (URtoUL = o = 0; o <= 335; URtoUL = ++o) {\n            results.push((function() {\n              var p, results1;\n              results1 = [];\n              for (UBtoDF = p = 0; p <= 335; UBtoDF = ++p) {\n                results1.push(mergeURtoDF(URtoUL, UBtoDF));\n              }\n              return results1;\n            })());\n          }\n          return results;\n        })();\n      } else {\n        [scope, size] = moveTableParams[tableName];\n        this.moveTables[tableName] = computeMoveTable(scope, tableName, size);\n      }\n    }\n    return this;\n  };\n\n  // Phase 1: All moves are valid\n  allMoves1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17];\n\n  // The list of next valid phase 1 moves when the given face was turned\n  // in the last move\n  nextMoves1 = (function() {\n    var face, lastFace, m, next, o, p, power, results;\n    results = [];\n    for (lastFace = m = 0; m <= 5; lastFace = ++m) {\n      next = [];\n// Don't allow commuting moves, e.g. U U'. Also make sure that\n// opposite faces are always moved in the same order, i.e. allow\n// U D but no D U. This avoids sequences like U D U'.\n      for (face = o = 0; o <= 5; face = ++o) {\n        if (face !== lastFace && face !== lastFace - 3) {\n// single, double or inverse move\n          for (power = p = 0; p <= 2; power = ++p) {\n            next.push(face * 3 + power);\n          }\n        }\n      }\n      results.push(next);\n    }\n    return results;\n  })();\n\n  // Phase 2: Double moves of all faces plus quarter moves of U and D\n  allMoves2 = [0, 1, 2, 4, 7, 9, 10, 11, 13, 16];\n\n  nextMoves2 = (function() {\n    var face, lastFace, len, m, next, o, p, power, powers, results;\n    results = [];\n    for (lastFace = m = 0; m <= 5; lastFace = ++m) {\n      next = [];\n      for (face = o = 0; o <= 5; face = ++o) {\n        if (!(face !== lastFace && face !== lastFace - 3)) {\n          continue;\n        }\n        // Allow all moves of U and D and double moves of others\n        powers = face === 0 || face === 3 ? [0, 1, 2] : [1];\n        for (p = 0, len = powers.length; p < len; p++) {\n          power = powers[p];\n          next.push(face * 3 + power);\n        }\n      }\n      results.push(next);\n    }\n    return results;\n  })();\n\n  // 8 values are encoded in one number\n  pruning = function(table, index, value) {\n    var pos, shift, slot;\n    pos = index % 8;\n    slot = index >> 3;\n    shift = pos << 2;\n    if (value != null) {\n      // Set\n      table[slot] &= ~(0xF << shift);\n      table[slot] |= value << shift;\n      return value;\n    } else {\n      // Get\n      return (table[slot] & (0xF << shift)) >>> shift;\n    }\n  };\n\n  computePruningTable = function(phase, size, currentCoords, nextIndex) {\n    var current, depth, done, index, len, m, move, moves, next, o, ref, table, x;\n    // Initialize all values to 0xF\n    table = (function() {\n      var m, ref, results;\n      results = [];\n      for (x = m = 0, ref = Math.ceil(size / 8) - 1; (0 <= ref ? m <= ref : m >= ref); x = 0 <= ref ? ++m : --m) {\n        results.push(0xFFFFFFFF);\n      }\n      return results;\n    })();\n    if (phase === 1) {\n      moves = allMoves1;\n    } else {\n      moves = allMoves2;\n    }\n    depth = 0;\n    pruning(table, 0, depth);\n    done = 1;\n    // In each iteration, take each state found in the previous depth and\n    // compute the next state. Stop when all states have been assigned a\n    // depth.\n    while (done !== size) {\n      for (index = m = 0, ref = size - 1; (0 <= ref ? m <= ref : m >= ref); index = 0 <= ref ? ++m : --m) {\n        if (!(pruning(table, index) === depth)) {\n          continue;\n        }\n        current = currentCoords(index);\n        for (o = 0, len = moves.length; o < len; o++) {\n          move = moves[o];\n          next = nextIndex(current, move);\n          if (pruning(table, next) === 0xF) {\n            pruning(table, next, depth + 1);\n            done++;\n          }\n        }\n      }\n      depth++;\n    }\n    return table;\n  };\n\n  Cube.pruningTables = {\n    sliceTwist: null,\n    sliceFlip: null,\n    sliceURFtoDLFParity: null,\n    sliceURtoDFParity: null\n  };\n\n  pruningTableParams = {\n    // name: [phase, size, currentCoords, nextIndex]\n    sliceTwist: [\n      1,\n      N_SLICE1 * N_TWIST,\n      function(index) {\n        return [index % N_SLICE1,\n      index / N_SLICE1 | 0];\n      },\n      function(current,\n      move) {\n        var newSlice,\n      newTwist,\n      slice,\n      twist;\n        [slice,\n      twist] = current;\n        newSlice = Cube.moveTables.FRtoBR[slice * 24][move] / 24 | 0;\n        newTwist = Cube.moveTables.twist[twist][move];\n        return newTwist * N_SLICE1 + newSlice;\n      }\n    ],\n    sliceFlip: [\n      1,\n      N_SLICE1 * N_FLIP,\n      function(index) {\n        return [index % N_SLICE1,\n      index / N_SLICE1 | 0];\n      },\n      function(current,\n      move) {\n        var flip,\n      newFlip,\n      newSlice,\n      slice;\n        [slice,\n      flip] = current;\n        newSlice = Cube.moveTables.FRtoBR[slice * 24][move] / 24 | 0;\n        newFlip = Cube.moveTables.flip[flip][move];\n        return newFlip * N_SLICE1 + newSlice;\n      }\n    ],\n    sliceURFtoDLFParity: [\n      2,\n      N_SLICE2 * N_URFtoDLF * N_PARITY,\n      function(index) {\n        return [index % 2,\n      (index / 2 | 0) % N_SLICE2,\n      (index / 2 | 0) / N_SLICE2 | 0];\n      },\n      function(current,\n      move) {\n        var URFtoDLF,\n      newParity,\n      newSlice,\n      newURFtoDLF,\n      parity,\n      slice;\n        [parity,\n      slice,\n      URFtoDLF] = current;\n        newParity = Cube.moveTables.parity[parity][move];\n        newSlice = Cube.moveTables.FRtoBR[slice][move];\n        newURFtoDLF = Cube.moveTables.URFtoDLF[URFtoDLF][move];\n        return (newURFtoDLF * N_SLICE2 + newSlice) * 2 + newParity;\n      }\n    ],\n    sliceURtoDFParity: [\n      2,\n      N_SLICE2 * N_URtoDF * N_PARITY,\n      function(index) {\n        return [index % 2,\n      (index / 2 | 0) % N_SLICE2,\n      (index / 2 | 0) / N_SLICE2 | 0];\n      },\n      function(current,\n      move) {\n        var URtoDF,\n      newParity,\n      newSlice,\n      newURtoDF,\n      parity,\n      slice;\n        [parity,\n      slice,\n      URtoDF] = current;\n        newParity = Cube.moveTables.parity[parity][move];\n        newSlice = Cube.moveTables.FRtoBR[slice][move];\n        newURtoDF = Cube.moveTables.URtoDF[URtoDF][move];\n        return (newURtoDF * N_SLICE2 + newSlice) * 2 + newParity;\n      }\n    ]\n  };\n\n  Cube.computePruningTables = function(...tables) {\n    var len, m, name, params, tableName;\n    if (tables.length === 0) {\n      tables = (function() {\n        var results;\n        results = [];\n        for (name in pruningTableParams) {\n          results.push(name);\n        }\n        return results;\n      })();\n    }\n    for (m = 0, len = tables.length; m < len; m++) {\n      tableName = tables[m];\n      if (this.pruningTables[tableName] !== null) {\n        // Already computed\n        continue;\n      }\n      params = pruningTableParams[tableName];\n      this.pruningTables[tableName] = computePruningTable(...params);\n    }\n    return this;\n  };\n\n  Cube.initSolver = function() {\n    Cube.computeMoveTables();\n    return Cube.computePruningTables();\n  };\n\n  Cube.prototype.solveUpright = function(maxDepth = 22) {\n    var State, freeStates, moveNames, phase1, phase1search, phase2, phase2search, solution, state, x;\n    // Names for all moves, i.e. U, U2, U', F, F2, ...\n    moveNames = (function() {\n      var face, faceName, m, o, power, powerName, result;\n      faceName = ['U', 'R', 'F', 'D', 'L', 'B'];\n      powerName = ['', '2', \"'\"];\n      result = [];\n      for (face = m = 0; m <= 5; face = ++m) {\n        for (power = o = 0; o <= 2; power = ++o) {\n          result.push(faceName[face] + powerName[power]);\n        }\n      }\n      return result;\n    })();\n    State = class State {\n      constructor(cube) {\n        this.parent = null;\n        this.lastMove = null;\n        this.depth = 0;\n        if (cube) {\n          this.init(cube);\n        }\n      }\n\n      init(cube) {\n        // Phase 1 coordinates\n        this.flip = cube.flip();\n        this.twist = cube.twist();\n        this.slice = cube.FRtoBR() / N_SLICE2 | 0;\n        // Phase 2 coordinates\n        this.parity = cube.cornerParity();\n        this.URFtoDLF = cube.URFtoDLF();\n        this.FRtoBR = cube.FRtoBR();\n        // These are later merged to URtoDF when phase 2 begins\n        this.URtoUL = cube.URtoUL();\n        this.UBtoDF = cube.UBtoDF();\n        return this;\n      }\n\n      solution() {\n        if (this.parent) {\n          return this.parent.solution() + moveNames[this.lastMove] + ' ';\n        } else {\n          return '';\n        }\n      }\n\n      //# Helpers\n      move(table, index, move) {\n        return Cube.moveTables[table][index][move];\n      }\n\n      pruning(table, index) {\n        return pruning(Cube.pruningTables[table], index);\n      }\n\n      //# Phase 1\n\n      // Return the next valid phase 1 moves for this state\n      moves1() {\n        if (this.lastMove !== null) {\n          return nextMoves1[this.lastMove / 3 | 0];\n        } else {\n          return allMoves1;\n        }\n      }\n\n      // Compute the minimum number of moves to the end of phase 1\n      minDist1() {\n        var d1, d2;\n        // The maximum number of moves to the end of phase 1 wrt. the\n        // combination flip and slice coordinates only\n        d1 = this.pruning('sliceFlip', N_SLICE1 * this.flip + this.slice);\n        // The combination of twist and slice coordinates\n        d2 = this.pruning('sliceTwist', N_SLICE1 * this.twist + this.slice);\n        // The true minimal distance is the maximum of these two\n        return max(d1, d2);\n      }\n\n      // Compute the next phase 1 state for the given move\n      next1(move) {\n        var next;\n        next = freeStates.pop();\n        next.parent = this;\n        next.lastMove = move;\n        next.depth = this.depth + 1;\n        next.flip = this.move('flip', this.flip, move);\n        next.twist = this.move('twist', this.twist, move);\n        next.slice = this.move('FRtoBR', this.slice * 24, move) / 24 | 0;\n        return next;\n      }\n\n      //# Phase 2\n\n      // Return the next valid phase 2 moves for this state\n      moves2() {\n        if (this.lastMove !== null) {\n          return nextMoves2[this.lastMove / 3 | 0];\n        } else {\n          return allMoves2;\n        }\n      }\n\n      // Compute the minimum number of moves to the solved cube\n      minDist2() {\n        var d1, d2, index1, index2;\n        index1 = (N_SLICE2 * this.URtoDF + this.FRtoBR) * N_PARITY + this.parity;\n        d1 = this.pruning('sliceURtoDFParity', index1);\n        index2 = (N_SLICE2 * this.URFtoDLF + this.FRtoBR) * N_PARITY + this.parity;\n        d2 = this.pruning('sliceURFtoDLFParity', index2);\n        return max(d1, d2);\n      }\n\n      // Initialize phase 2 coordinates\n      init2(top = true) {\n        if (this.parent === null) {\n          return;\n        }\n        // For other states, the phase 2 state is computed based on\n        // parent's state.\n        // Already assigned for the initial state\n        this.parent.init2(false);\n        this.URFtoDLF = this.move('URFtoDLF', this.parent.URFtoDLF, this.lastMove);\n        this.FRtoBR = this.move('FRtoBR', this.parent.FRtoBR, this.lastMove);\n        this.parity = this.move('parity', this.parent.parity, this.lastMove);\n        this.URtoUL = this.move('URtoUL', this.parent.URtoUL, this.lastMove);\n        this.UBtoDF = this.move('UBtoDF', this.parent.UBtoDF, this.lastMove);\n        if (top) {\n          // This is the initial phase 2 state. Get the URtoDF coordinate\n          // by merging URtoUL and UBtoDF\n          return this.URtoDF = this.move('mergeURtoDF', this.URtoUL, this.UBtoDF);\n        }\n      }\n\n      // Compute the next phase 2 state for the given move\n      next2(move) {\n        var next;\n        next = freeStates.pop();\n        next.parent = this;\n        next.lastMove = move;\n        next.depth = this.depth + 1;\n        next.URFtoDLF = this.move('URFtoDLF', this.URFtoDLF, move);\n        next.FRtoBR = this.move('FRtoBR', this.FRtoBR, move);\n        next.parity = this.move('parity', this.parity, move);\n        next.URtoDF = this.move('URtoDF', this.URtoDF, move);\n        return next;\n      }\n\n    };\n    solution = null;\n    phase1search = function(state) {\n      var depth, m, ref, results;\n      depth = 0;\n      results = [];\n      for (depth = m = 1, ref = maxDepth; (1 <= ref ? m <= ref : m >= ref); depth = 1 <= ref ? ++m : --m) {\n        phase1(state, depth);\n        if (solution !== null) {\n          break;\n        }\n        results.push(depth++);\n      }\n      return results;\n    };\n    phase1 = function(state, depth) {\n      var len, m, move, next, ref, ref1, results;\n      if (depth === 0) {\n        if (state.minDist1() === 0) {\n          // Make sure we don't start phase 2 with a phase 2 move as the\n          // last move in phase 1, because phase 2 would then repeat the\n          // same move.\n          if (state.lastMove === null || (ref = state.lastMove, indexOf.call(allMoves2, ref) < 0)) {\n            return phase2search(state);\n          }\n        }\n      } else if (depth > 0) {\n        if (state.minDist1() <= depth) {\n          ref1 = state.moves1();\n          results = [];\n          for (m = 0, len = ref1.length; m < len; m++) {\n            move = ref1[m];\n            next = state.next1(move);\n            phase1(next, depth - 1);\n            freeStates.push(next);\n            if (solution !== null) {\n              break;\n            } else {\n              results.push(void 0);\n            }\n          }\n          return results;\n        }\n      }\n    };\n    phase2search = function(state) {\n      var depth, m, ref, results;\n      // Initialize phase 2 coordinates\n      state.init2();\n      results = [];\n      for (depth = m = 1, ref = maxDepth - state.depth; (1 <= ref ? m <= ref : m >= ref); depth = 1 <= ref ? ++m : --m) {\n        phase2(state, depth);\n        if (solution !== null) {\n          break;\n        }\n        results.push(depth++);\n      }\n      return results;\n    };\n    phase2 = function(state, depth) {\n      var len, m, move, next, ref, results;\n      if (depth === 0) {\n        if (state.minDist2() === 0) {\n          return solution = state.solution();\n        }\n      } else if (depth > 0) {\n        if (state.minDist2() <= depth) {\n          ref = state.moves2();\n          results = [];\n          for (m = 0, len = ref.length; m < len; m++) {\n            move = ref[m];\n            next = state.next2(move);\n            phase2(next, depth - 1);\n            freeStates.push(next);\n            if (solution !== null) {\n              break;\n            } else {\n              results.push(void 0);\n            }\n          }\n          return results;\n        }\n      }\n    };\n    freeStates = (function() {\n      var m, ref, results;\n      results = [];\n      for (x = m = 0, ref = maxDepth + 1; (0 <= ref ? m <= ref : m >= ref); x = 0 <= ref ? ++m : --m) {\n        results.push(new State);\n      }\n      return results;\n    })();\n    state = freeStates.pop().init(this);\n    phase1search(state);\n    freeStates.push(state);\n    // Trim the trailing space\n    if (solution.length > 0) {\n      solution = solution.substring(0, solution.length - 1);\n    }\n    return solution;\n  };\n\n  faceNums = {\n    U: 0,\n    R: 1,\n    F: 2,\n    D: 3,\n    L: 4,\n    B: 5\n  };\n\n  faceNames = {\n    0: 'U',\n    1: 'R',\n    2: 'F',\n    3: 'D',\n    4: 'L',\n    5: 'B'\n  };\n\n  Cube.prototype.solve = function(maxDepth = 22) {\n    var clone, len, m, move, ref, rotation, solution, upright, uprightSolution;\n    clone = this.clone();\n    upright = clone.upright();\n    clone.move(upright);\n    rotation = new Cube().move(upright).center;\n    uprightSolution = clone.solveUpright(maxDepth);\n    solution = [];\n    ref = uprightSolution.split(' ');\n    for (m = 0, len = ref.length; m < len; m++) {\n      move = ref[m];\n      solution.push(faceNames[rotation[faceNums[move[0]]]]);\n      if (move.length > 1) {\n        solution[solution.length - 1] += move[1];\n      }\n    }\n    return solution.join(' ');\n  };\n\n  Cube.scramble = function() {\n    return Cube.inverse(Cube.random().solve());\n  };\n\n}).call(this);\n","(function() {\n  // Centers\n  var B, BL, BR, Cube, D, DB, DBL, DF, DFR, DL, DLF, DR, DRB, F, FL, FR, L, R, U, UB, UBR, UF, UFL, UL, ULB, UR, URF, centerColor, centerFacelet, cornerColor, cornerFacelet, edgeColor, edgeFacelet;\n\n  [U, R, F, D, L, B] = [0, 1, 2, 3, 4, 5];\n\n  // Corners\n  [URF, UFL, ULB, UBR, DFR, DLF, DBL, DRB] = [0, 1, 2, 3, 4, 5, 6, 7];\n\n  // Edges\n  [UR, UF, UL, UB, DR, DF, DL, DB, FR, FL, BL, BR] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n\n  [centerFacelet, cornerFacelet, edgeFacelet] = (function() {\n    var _B, _D, _F, _L, _R, _U;\n    _U = function(x) {\n      return x - 1;\n    };\n    _R = function(x) {\n      return _U(9) + x;\n    };\n    _F = function(x) {\n      return _R(9) + x;\n    };\n    _D = function(x) {\n      return _F(9) + x;\n    };\n    _L = function(x) {\n      return _D(9) + x;\n    };\n    _B = function(x) {\n      return _L(9) + x;\n    };\n    return [\n      // Centers\n      [4,\n      13,\n      22,\n      31,\n      40,\n      49],\n      // Corners\n      [[_U(9),\n      _R(1),\n      _F(3)],\n      [_U(7),\n      _F(1),\n      _L(3)],\n      [_U(1),\n      _L(1),\n      _B(3)],\n      [_U(3),\n      _B(1),\n      _R(3)],\n      [_D(3),\n      _F(9),\n      _R(7)],\n      [_D(1),\n      _L(9),\n      _F(7)],\n      [_D(7),\n      _B(9),\n      _L(7)],\n      [_D(9),\n      _R(9),\n      _B(7)]],\n      // Edges\n      [[_U(6),\n      _R(2)],\n      [_U(8),\n      _F(2)],\n      [_U(4),\n      _L(2)],\n      [_U(2),\n      _B(2)],\n      [_D(6),\n      _R(8)],\n      [_D(2),\n      _F(8)],\n      [_D(4),\n      _L(8)],\n      [_D(8),\n      _B(8)],\n      [_F(6),\n      _R(4)],\n      [_F(4),\n      _L(6)],\n      [_B(6),\n      _L(4)],\n      [_B(4),\n      _R(6)]]\n    ];\n  })();\n\n  centerColor = ['U', 'R', 'F', 'D', 'L', 'B'];\n\n  cornerColor = [['U', 'R', 'F'], ['U', 'F', 'L'], ['U', 'L', 'B'], ['U', 'B', 'R'], ['D', 'F', 'R'], ['D', 'L', 'F'], ['D', 'B', 'L'], ['D', 'R', 'B']];\n\n  edgeColor = [['U', 'R'], ['U', 'F'], ['U', 'L'], ['U', 'B'], ['D', 'R'], ['D', 'F'], ['D', 'L'], ['D', 'B'], ['F', 'R'], ['F', 'L'], ['B', 'L'], ['B', 'R']];\n\n  Cube = (function() {\n    var faceNames, faceNums, parseAlg;\n\n    class Cube {\n      constructor(other) {\n        var x;\n        if (other != null) {\n          this.init(other);\n        } else {\n          this.identity();\n        }\n        // For moves to avoid allocating new objects each time\n        this.newCenter = (function() {\n          var k, results;\n          results = [];\n          for (x = k = 0; k <= 5; x = ++k) {\n            results.push(0);\n          }\n          return results;\n        })();\n        this.newCp = (function() {\n          var k, results;\n          results = [];\n          for (x = k = 0; k <= 7; x = ++k) {\n            results.push(0);\n          }\n          return results;\n        })();\n        this.newEp = (function() {\n          var k, results;\n          results = [];\n          for (x = k = 0; k <= 11; x = ++k) {\n            results.push(0);\n          }\n          return results;\n        })();\n        this.newCo = (function() {\n          var k, results;\n          results = [];\n          for (x = k = 0; k <= 7; x = ++k) {\n            results.push(0);\n          }\n          return results;\n        })();\n        this.newEo = (function() {\n          var k, results;\n          results = [];\n          for (x = k = 0; k <= 11; x = ++k) {\n            results.push(0);\n          }\n          return results;\n        })();\n      }\n\n      init(state) {\n        this.center = state.center.slice(0);\n        this.co = state.co.slice(0);\n        this.ep = state.ep.slice(0);\n        this.cp = state.cp.slice(0);\n        return this.eo = state.eo.slice(0);\n      }\n\n      identity() {\n        var x;\n        // Initialize to the identity cube\n        this.center = [0, 1, 2, 3, 4, 5];\n        this.cp = [0, 1, 2, 3, 4, 5, 6, 7];\n        this.co = (function() {\n          var k, results;\n          results = [];\n          for (x = k = 0; k <= 7; x = ++k) {\n            results.push(0);\n          }\n          return results;\n        })();\n        this.ep = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n        return this.eo = (function() {\n          var k, results;\n          results = [];\n          for (x = k = 0; k <= 11; x = ++k) {\n            results.push(0);\n          }\n          return results;\n        })();\n      }\n\n      toJSON() {\n        return {\n          center: this.center,\n          cp: this.cp,\n          co: this.co,\n          ep: this.ep,\n          eo: this.eo\n        };\n      }\n\n      asString() {\n        var corner, edge, i, k, l, m, n, o, ori, p, result;\n        result = [];\n        for (i = k = 0; k <= 5; i = ++k) {\n          result[9 * i + 4] = centerColor[this.center[i]];\n        }\n        for (i = l = 0; l <= 7; i = ++l) {\n          corner = this.cp[i];\n          ori = this.co[i];\n          for (n = m = 0; m <= 2; n = ++m) {\n            result[cornerFacelet[i][(n + ori) % 3]] = cornerColor[corner][n];\n          }\n        }\n        for (i = o = 0; o <= 11; i = ++o) {\n          edge = this.ep[i];\n          ori = this.eo[i];\n          for (n = p = 0; p <= 1; n = ++p) {\n            result[edgeFacelet[i][(n + ori) % 2]] = edgeColor[edge][n];\n          }\n        }\n        return result.join('');\n      }\n\n      static fromString(str) {\n        var col1, col2, cube, i, j, k, l, m, o, ori, p, q, r, ref;\n        cube = new Cube;\n        for (i = k = 0; k <= 5; i = ++k) {\n          for (j = l = 0; l <= 5; j = ++l) {\n            if (str[9 * i + 4] === centerColor[j]) {\n              cube.center[i] = j;\n            }\n          }\n        }\n        for (i = m = 0; m <= 7; i = ++m) {\n          for (ori = o = 0; o <= 2; ori = ++o) {\n            if ((ref = str[cornerFacelet[i][ori]]) === 'U' || ref === 'D') {\n              break;\n            }\n          }\n          col1 = str[cornerFacelet[i][(ori + 1) % 3]];\n          col2 = str[cornerFacelet[i][(ori + 2) % 3]];\n          for (j = p = 0; p <= 7; j = ++p) {\n            if (col1 === cornerColor[j][1] && col2 === cornerColor[j][2]) {\n              cube.cp[i] = j;\n              cube.co[i] = ori % 3;\n            }\n          }\n        }\n        for (i = q = 0; q <= 11; i = ++q) {\n          for (j = r = 0; r <= 11; j = ++r) {\n            if (str[edgeFacelet[i][0]] === edgeColor[j][0] && str[edgeFacelet[i][1]] === edgeColor[j][1]) {\n              cube.ep[i] = j;\n              cube.eo[i] = 0;\n              break;\n            }\n            if (str[edgeFacelet[i][0]] === edgeColor[j][1] && str[edgeFacelet[i][1]] === edgeColor[j][0]) {\n              cube.ep[i] = j;\n              cube.eo[i] = 1;\n              break;\n            }\n          }\n        }\n        return cube;\n      }\n\n      clone() {\n        return new Cube(this.toJSON());\n      }\n\n      // A class method returning a new random cube\n      static random() {\n        return new Cube().randomize();\n      }\n\n      isSolved() {\n        var c, cent, clone, e, k, l, m;\n        clone = this.clone();\n        clone.move(clone.upright());\n        for (cent = k = 0; k <= 5; cent = ++k) {\n          if (clone.center[cent] !== cent) {\n            return false;\n          }\n        }\n        for (c = l = 0; l <= 7; c = ++l) {\n          if (clone.cp[c] !== c) {\n            return false;\n          }\n          if (clone.co[c] !== 0) {\n            return false;\n          }\n        }\n        for (e = m = 0; m <= 11; e = ++m) {\n          if (clone.ep[e] !== e) {\n            return false;\n          }\n          if (clone.eo[e] !== 0) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      // Multiply this Cube with another Cube, restricted to centers.\n      centerMultiply(other) {\n        var from, k, to;\n        for (to = k = 0; k <= 5; to = ++k) {\n          from = other.center[to];\n          this.newCenter[to] = this.center[from];\n        }\n        [this.center, this.newCenter] = [this.newCenter, this.center];\n        return this;\n      }\n\n      // Multiply this Cube with another Cube, restricted to corners.\n      cornerMultiply(other) {\n        var from, k, to;\n        for (to = k = 0; k <= 7; to = ++k) {\n          from = other.cp[to];\n          this.newCp[to] = this.cp[from];\n          this.newCo[to] = (this.co[from] + other.co[to]) % 3;\n        }\n        [this.cp, this.newCp] = [this.newCp, this.cp];\n        [this.co, this.newCo] = [this.newCo, this.co];\n        return this;\n      }\n\n      // Multiply this Cube with another Cube, restricted to edges\n      edgeMultiply(other) {\n        var from, k, to;\n        for (to = k = 0; k <= 11; to = ++k) {\n          from = other.ep[to];\n          this.newEp[to] = this.ep[from];\n          this.newEo[to] = (this.eo[from] + other.eo[to]) % 2;\n        }\n        [this.ep, this.newEp] = [this.newEp, this.ep];\n        [this.eo, this.newEo] = [this.newEo, this.eo];\n        return this;\n      }\n\n      // Multiply this cube with another Cube\n      multiply(other) {\n        this.centerMultiply(other);\n        this.cornerMultiply(other);\n        this.edgeMultiply(other);\n        return this;\n      }\n\n      move(arg) {\n        var face, k, l, len, move, power, ref, ref1, x;\n        ref = parseAlg(arg);\n        for (k = 0, len = ref.length; k < len; k++) {\n          move = ref[k];\n          face = move / 3 | 0;\n          power = move % 3;\n          for (x = l = 0, ref1 = power; (0 <= ref1 ? l <= ref1 : l >= ref1); x = 0 <= ref1 ? ++l : --l) {\n            this.multiply(Cube.moves[face]);\n          }\n        }\n        return this;\n      }\n\n      upright() {\n        var clone, i, j, k, l, result;\n        clone = this.clone();\n        result = [];\n        for (i = k = 0; k <= 5; i = ++k) {\n          if (clone.center[i] === F) {\n            break;\n          }\n        }\n        switch (i) {\n          case D:\n            result.push(\"x\");\n            break;\n          case U:\n            result.push(\"x'\");\n            break;\n          case B:\n            result.push(\"x2\");\n            break;\n          case R:\n            result.push(\"y\");\n            break;\n          case L:\n            result.push(\"y'\");\n        }\n        if (result.length) {\n          clone.move(result[0]);\n        }\n        for (j = l = 0; l <= 5; j = ++l) {\n          if (clone.center[j] === U) {\n            break;\n          }\n        }\n        switch (j) {\n          case L:\n            result.push(\"z\");\n            break;\n          case R:\n            result.push(\"z'\");\n            break;\n          case D:\n            result.push(\"z2\");\n        }\n        return result.join(' ');\n      }\n\n      static inverse(arg) {\n        var face, k, len, move, power, result, str;\n        result = (function() {\n          var k, len, ref, results;\n          ref = parseAlg(arg);\n          results = [];\n          for (k = 0, len = ref.length; k < len; k++) {\n            move = ref[k];\n            face = move / 3 | 0;\n            power = move % 3;\n            results.push(face * 3 + -(power - 1) + 1);\n          }\n          return results;\n        })();\n        result.reverse();\n        if (typeof arg === 'string') {\n          str = '';\n          for (k = 0, len = result.length; k < len; k++) {\n            move = result[k];\n            face = move / 3 | 0;\n            power = move % 3;\n            str += faceNames[face];\n            if (power === 1) {\n              str += '2';\n            } else if (power === 2) {\n              str += \"'\";\n            }\n            str += ' ';\n          }\n          return str.substring(0, str.length - 1);\n        } else if (arg.length != null) {\n          return result;\n        } else {\n          return result[0];\n        }\n      }\n\n    };\n\n    Cube.prototype.randomize = (function() {\n      var arePermutationsValid, generateValidRandomOrientation, generateValidRandomPermutation, getNumSwaps, isOrientationValid, randint, randomizeOrientation, result, shuffle;\n      randint = function(min, max) {\n        return min + Math.floor(Math.random() * (max - min + 1));\n      };\n      // Fisher-Yates shuffle adapted from https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\n      shuffle = function(array) {\n        var currentIndex, randomIndex, temporaryValue;\n        currentIndex = array.length;\n        // While there remain elements to shuffle...\n        while (currentIndex !== 0) {\n          // Pick a remaining element...\n          randomIndex = randint(0, currentIndex - 1);\n          currentIndex -= 1;\n          // And swap it with the current element.\n          temporaryValue = array[currentIndex];\n          [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];\n        }\n      };\n      getNumSwaps = function(arr) {\n        var cur, cycleLength, i, k, numSwaps, ref, seen, x;\n        numSwaps = 0;\n        seen = (function() {\n          var k, ref, results;\n          results = [];\n          for (x = k = 0, ref = arr.length - 1; (0 <= ref ? k <= ref : k >= ref); x = 0 <= ref ? ++k : --k) {\n            results.push(false);\n          }\n          return results;\n        })();\n        while (true) {\n          // We compute the cycle decomposition\n          cur = -1;\n          for (i = k = 0, ref = arr.length - 1; (0 <= ref ? k <= ref : k >= ref); i = 0 <= ref ? ++k : --k) {\n            if (!seen[i]) {\n              cur = i;\n              break;\n            }\n          }\n          if (cur === -1) {\n            break;\n          }\n          cycleLength = 0;\n          while (!seen[cur]) {\n            seen[cur] = true;\n            cycleLength++;\n            cur = arr[cur];\n          }\n          // A cycle is equivalent to cycleLength + 1 swaps\n          numSwaps += cycleLength + 1;\n        }\n        return numSwaps;\n      };\n      arePermutationsValid = function(cp, ep) {\n        var numSwaps;\n        numSwaps = getNumSwaps(ep) + getNumSwaps(cp);\n        return numSwaps % 2 === 0;\n      };\n      generateValidRandomPermutation = function(cp, ep) {\n        // Each shuffle only takes around 12 operations and there's a 50%\n        // chance of a valid permutation so it'll finish in very good time\n        shuffle(ep);\n        shuffle(cp);\n        while (!arePermutationsValid(cp, ep)) {\n          shuffle(ep);\n          shuffle(cp);\n        }\n      };\n      randomizeOrientation = function(arr, numOrientations) {\n        var i, k, ori, ref;\n        ori = 0;\n        for (i = k = 0, ref = arr.length - 1; (0 <= ref ? k <= ref : k >= ref); i = 0 <= ref ? ++k : --k) {\n          ori += (arr[i] = randint(0, numOrientations - 1));\n        }\n      };\n      isOrientationValid = function(arr, numOrientations) {\n        return arr.reduce(function(a, b) {\n          return a + b;\n        }) % numOrientations === 0;\n      };\n      generateValidRandomOrientation = function(co, eo) {\n        // There is a 1/2 and 1/3 probably respectively of each of these\n        // succeeding so the probability of them running 10 times before\n        // success is already only 1% and only gets exponentially lower\n        // and each generation is only in the 10s of operations which is nothing\n        randomizeOrientation(co, 3);\n        while (!isOrientationValid(co, 3)) {\n          randomizeOrientation(co, 3);\n        }\n        randomizeOrientation(eo, 2);\n        while (!isOrientationValid(eo, 2)) {\n          randomizeOrientation(eo, 2);\n        }\n      };\n      result = function() {\n        generateValidRandomPermutation(this.cp, this.ep);\n        generateValidRandomOrientation(this.co, this.eo);\n        return this;\n      };\n      return result;\n    })();\n\n    Cube.moves = [\n      {\n        // U\n        center: [0, 1, 2, 3, 4, 5],\n        cp: [UBR,\n      URF,\n      UFL,\n      ULB,\n      DFR,\n      DLF,\n      DBL,\n      DRB],\n        co: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0],\n        ep: [UB,\n      UR,\n      UF,\n      UL,\n      DR,\n      DF,\n      DL,\n      DB,\n      FR,\n      FL,\n      BL,\n      BR],\n        eo: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0]\n      },\n      {\n        // R\n        center: [0, 1, 2, 3, 4, 5],\n        cp: [DFR,\n      UFL,\n      ULB,\n      URF,\n      DRB,\n      DLF,\n      DBL,\n      UBR],\n        co: [2,\n      0,\n      0,\n      1,\n      1,\n      0,\n      0,\n      2],\n        ep: [FR,\n      UF,\n      UL,\n      UB,\n      BR,\n      DF,\n      DL,\n      DB,\n      DR,\n      FL,\n      BL,\n      UR],\n        eo: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0]\n      },\n      {\n        // F\n        center: [0, 1, 2, 3, 4, 5],\n        cp: [UFL,\n      DLF,\n      ULB,\n      UBR,\n      URF,\n      DFR,\n      DBL,\n      DRB],\n        co: [1,\n      2,\n      0,\n      0,\n      2,\n      1,\n      0,\n      0],\n        ep: [UR,\n      FL,\n      UL,\n      UB,\n      DR,\n      FR,\n      DL,\n      DB,\n      UF,\n      DF,\n      BL,\n      BR],\n        eo: [0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      1,\n      1,\n      0,\n      0]\n      },\n      {\n        // D\n        center: [0, 1, 2, 3, 4, 5],\n        cp: [URF,\n      UFL,\n      ULB,\n      UBR,\n      DLF,\n      DBL,\n      DRB,\n      DFR],\n        co: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0],\n        ep: [UR,\n      UF,\n      UL,\n      UB,\n      DF,\n      DL,\n      DB,\n      DR,\n      FR,\n      FL,\n      BL,\n      BR],\n        eo: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0]\n      },\n      {\n        // L\n        center: [0, 1, 2, 3, 4, 5],\n        cp: [URF,\n      ULB,\n      DBL,\n      UBR,\n      DFR,\n      UFL,\n      DLF,\n      DRB],\n        co: [0,\n      1,\n      2,\n      0,\n      0,\n      2,\n      1,\n      0],\n        ep: [UR,\n      UF,\n      BL,\n      UB,\n      DR,\n      DF,\n      FL,\n      DB,\n      FR,\n      UL,\n      DL,\n      BR],\n        eo: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0]\n      },\n      {\n        // B\n        center: [0, 1, 2, 3, 4, 5],\n        cp: [URF,\n      UFL,\n      UBR,\n      DRB,\n      DFR,\n      DLF,\n      ULB,\n      DBL],\n        co: [0,\n      0,\n      1,\n      2,\n      0,\n      0,\n      2,\n      1],\n        ep: [UR,\n      UF,\n      UL,\n      BR,\n      DR,\n      DF,\n      DL,\n      BL,\n      FR,\n      FL,\n      UB,\n      DB],\n        eo: [0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      1,\n      1]\n      },\n      {\n        // E\n        center: [U,\n      F,\n      L,\n      D,\n      B,\n      R],\n        cp: [URF,\n      UFL,\n      ULB,\n      UBR,\n      DFR,\n      DLF,\n      DBL,\n      DRB],\n        co: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0],\n        ep: [UR,\n      UF,\n      UL,\n      UB,\n      DR,\n      DF,\n      DL,\n      DB,\n      FL,\n      BL,\n      BR,\n      FR],\n        eo: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      1,\n      1,\n      1]\n      },\n      {\n        // M\n        center: [B,\n      R,\n      U,\n      F,\n      L,\n      D],\n        cp: [URF,\n      UFL,\n      ULB,\n      UBR,\n      DFR,\n      DLF,\n      DBL,\n      DRB],\n        co: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0],\n        ep: [UR,\n      UB,\n      UL,\n      DB,\n      DR,\n      UF,\n      DL,\n      DF,\n      FR,\n      FL,\n      BL,\n      BR],\n        eo: [0,\n      1,\n      0,\n      1,\n      0,\n      1,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0]\n      },\n      {\n        // S\n        center: [L,\n      U,\n      F,\n      R,\n      D,\n      B],\n        cp: [URF,\n      UFL,\n      ULB,\n      UBR,\n      DFR,\n      DLF,\n      DBL,\n      DRB],\n        co: [0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0],\n        ep: [UL,\n      UF,\n      DL,\n      UB,\n      UR,\n      DF,\n      DR,\n      DB,\n      FR,\n      FL,\n      BL,\n      BR],\n        eo: [1,\n      0,\n      1,\n      0,\n      1,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0]\n      }\n    ];\n\n    faceNums = {\n      U: 0,\n      R: 1,\n      F: 2,\n      D: 3,\n      L: 4,\n      B: 5,\n      E: 6,\n      M: 7,\n      S: 8,\n      x: 9,\n      y: 10,\n      z: 11,\n      u: 12,\n      r: 13,\n      f: 14,\n      d: 15,\n      l: 16,\n      b: 17\n    };\n\n    faceNames = {\n      0: 'U',\n      1: 'R',\n      2: 'F',\n      3: 'D',\n      4: 'L',\n      5: 'B',\n      6: 'E',\n      7: 'M',\n      8: 'S',\n      9: 'x',\n      10: 'y',\n      11: 'z',\n      12: 'u',\n      13: 'r',\n      14: 'f',\n      15: 'd',\n      16: 'l',\n      17: 'b'\n    };\n\n    parseAlg = function(arg) {\n      var k, len, move, part, power, ref, results;\n      if (typeof arg === 'string') {\n        ref = arg.split(/\\s+/);\n        // String\n        results = [];\n        for (k = 0, len = ref.length; k < len; k++) {\n          part = ref[k];\n          if (part.length === 0) {\n            // First and last can be empty\n            continue;\n          }\n          if (part.length > 2) {\n            throw new Error(`Invalid move: ${part}`);\n          }\n          move = faceNums[part[0]];\n          if (move === void 0) {\n            throw new Error(`Invalid move: ${part}`);\n          }\n          if (part.length === 1) {\n            power = 0;\n          } else {\n            if (part[1] === '2') {\n              power = 1;\n            } else if (part[1] === \"'\") {\n              power = 2;\n            } else {\n              throw new Error(`Invalid move: ${part}`);\n            }\n          }\n          results.push(move * 3 + power);\n        }\n        return results;\n      } else if (arg.length != null) {\n        // Already an array\n        return arg;\n      } else {\n        // A single move\n        return [arg];\n      }\n    };\n\n    // x\n    Cube.moves.push(new Cube().move(\"R M' L'\").toJSON());\n\n    // y\n    Cube.moves.push(new Cube().move(\"U E' D'\").toJSON());\n\n    // z\n    Cube.moves.push(new Cube().move(\"F S B'\").toJSON());\n\n    // u\n    Cube.moves.push(new Cube().move(\"U E'\").toJSON());\n\n    // r\n    Cube.moves.push(new Cube().move(\"R M'\").toJSON());\n\n    // f\n    Cube.moves.push(new Cube().move(\"F S\").toJSON());\n\n    // d\n    Cube.moves.push(new Cube().move(\"D E\").toJSON());\n\n    // l\n    Cube.moves.push(new Cube().move(\"L M\").toJSON());\n\n    // b\n    Cube.moves.push(new Cube().move(\"B S'\").toJSON());\n\n    return Cube;\n\n  }).call(this);\n\n  //# Globals\n  if (typeof module !== \"undefined\" && module !== null) {\n    module.exports = Cube;\n  } else {\n    this.Cube = Cube;\n  }\n\n}).call(this);\n","// tslint:disable:no-var-requires\r\nconst cubejs = require('cubejs')\r\nrequire('cubejs/lib/solve.js')\r\n\r\nconst ctx: Worker = self as any\r\nlet initialized = false\r\n\r\nctx.onmessage = (event: MessageEvent) => {\r\n    switch (event.data.cmd) {\r\n        case 'init':\r\n            cubejs.initSolver()\r\n            initialized = true\r\n            ctx.postMessage({ cmd: 'init', done: true })\r\n            break\r\n        case 'scramble':\r\n            if (!initialized) {\r\n                cubejs.initSolver()\r\n            }\r\n            const s = cubejs.scramble()\r\n            ctx.postMessage({ cmd: 'scramble', scramble: s})\r\n            break\r\n    }\r\n}\r\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n"],"sourceRoot":""}